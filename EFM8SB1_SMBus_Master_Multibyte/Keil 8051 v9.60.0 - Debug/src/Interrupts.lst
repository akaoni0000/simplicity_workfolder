C51 COMPILER V9.60.0.0   INTERRUPTS                                                        08/25/2024 21:07:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INTERRUPTS
OBJECT MODULE PLACED IN .\src\Interrupts.OBJ
COMPILER INVOKED BY: C:\SiliconLabs\SimplicityStudio\v5\developer\toolchains\keil_8051\9.60\BIN\C51.exe C:\Users\Yoshida
                    -_Lab\SimplicityStudio\v5_workspace\EFM8SB1_SMBus_Master_Multibyte\src\Interrupts.c OMF2 SMALL DEBUG OBJECTEXTEND ROM(LAR
                    -GE) WARNINGLEVEL(2) FLOATFUZZY(3) OPTIMIZE(8,SPEED) DEFINE(DEBUG=1) INTVECTOR(0X0000) INTPROMOTE INCDIR(C:\Users\Yoshida
                    -_Lab\SimplicityStudio\v5_workspace\EFM8SB1_SMBus_Master_Multibyte\inc;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/
                    -8051/v4.3.1//Device/shared/si8051Base;C:/SiliconLabs/SimplicityStudio/v5/developer/sdks/8051/v4.3.1//Device/EFM8SB1/inc)
                    - PRINT(.\src\Interrupts.lst) COND PAGEWIDTH(120) PAGELENGTH(65) OBJECT(.\src\Interrupts.OBJ)

line level    source

   1          //=========================================================
   2          // src/Interrupts.c: generated by Hardware Configurator
   3          //
   4          // This file will be regenerated when saving a document.
   5          // leave the sections inside the "$[...]" comment tags alone
   6          // or they will be overwritten!
   7          //=========================================================
   8          
   9          
  10          // USER INCLUDES
  11          #include <SI_EFM8SB1_Register_Enums.h>
  12          #include "EFM8SB1_SMBus_Master_Multibyte.h"
  13          
  14          //-----------------------------------------------------------------------------
  15          // SMBUS0_ISR
  16          //-----------------------------------------------------------------------------
  17          //
  18          // SMBUS0 ISR Content goes here. Remember to clear flag bits:
  19          // SMB0CN0::SI (SMBus Interrupt Flag)
  20          //
  21          //-----------------------------------------------------------------------------
  22          SI_INTERRUPT(SMBUS0_ISR, SMBUS0_IRQn)
  23          {
  24   1              bool FAIL = 0;                       // Used by the ISR to flag failed
  25   1                                                                                 // transfers
  26   1      
  27   1              static uint8_t sent_byte_counter;
  28   1              static uint8_t rec_byte_counter;
  29   1      
  30   1              if (SMB0CN0_ARBLOST == 0)                   // Check for errors
  31   1              {
  32   2                // Normal operation
  33   2                switch (SMB0CN0 & 0xF0)           // Status vector
  34   2                {
  35   3                       // Master Transmitter/Receiver: START condition transmitted.
  36   3                       case SMB_MTSTA:
  37   3                              SMB0DAT = TARGET;          // Load address of the target slave
  38   3                              SMB0DAT &= 0xFE;           // Clear the LSB of the address for the
  39   3                                                                                 // R/W bit
  40   3                              SMB0DAT |= (uint8_t) SMB_RW;    // Load R/W bit
  41   3                              SMB0CN0_STA = 0;                   // Manually clear START bit
  42   3                              rec_byte_counter = 1;      // Reset the counter
  43   3                              sent_byte_counter = 1;     // Reset the counter
  44   3                              break;
  45   3      
  46   3                       // Master Transmitter: Data byte transmitted
  47   3                       case SMB_MTDB:
  48   3                              if (SMB0CN0_ACK)                   // Slave SMB0CN0_ACK?
  49   3                              {
  50   4                                 if (SMB_RW == WRITE)    // If this transfer is a WRITE,
  51   4                                 {
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        08/25/2024 21:07:34 PAGE 2   

  52   5                                        if (sent_byte_counter <= NUM_BYTES_WR)
  53   5                                        {
  54   6                                               // send data byte
  55   6                                               SMB0DAT = SMB_DATA_OUT[sent_byte_counter-1];
  56   6                                               sent_byte_counter++;
  57   6                                        }
  58   5                                        else
  59   5                                        {
  60   6                                               SMB0CN0_STO = 1;          // Set SMB0CN0_STO to terminate transfer
  61   6                                               SMB_BUSY = 0;     // And free SMBus interface
  62   6                                        }
  63   5                                 }
  64   4                                 else {}                 // If this transfer is a READ,
  65   4                                                                                 // proceed with transfer without
  66   4                                                                                 // writing to SMB0DAT (switch
  67   4                                                                                 // to receive mode)
  68   4      
  69   4      
  70   4                              }
  71   3                              else                       // If slave NACK,
  72   3                              {
  73   4                                 SMB0CN0_STO = 1;                // Send STOP condition, followed
  74   4                                 SMB0CN0_STA = 1;                // By a START
  75   4                                 NUM_ERRORS++;           // Indicate error
  76   4                              }
  77   3                              break;
  78   3      
  79   3                       // Master Receiver: byte received
  80   3                       case SMB_MRDB:
  81   3                              if (rec_byte_counter < NUM_BYTES_RD)
  82   3                              {
  83   4                                 SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
  84   4                                                                                                                       // byte
  85   4                                 SMB0CN0_ACK = 1;                 // Send SMB0CN0_ACK to indicate byte received
  86   4                                 rec_byte_counter++;      // Increment the byte counter
  87   4                              }
  88   3                              else
  89   3                              {
  90   4                                 SMB_DATA_IN[rec_byte_counter-1] = SMB0DAT; // Store received
  91   4                                                                                                                       // byte
  92   4                                 SMB_BUSY = 0;            // Free SMBus interface
  93   4                                 SMB0CN0_ACK = 0;                 // Send NACK to indicate last byte
  94   4                                                                                 // of this transfer
  95   4      
  96   4                                 SMB0CN0_STO = 1;                 // Send STOP to terminate transfer
  97   4                              }
  98   3                              break;
  99   3      
 100   3                       default:
 101   3                              FAIL = 1;                  // Indicate failed transfer
 102   3                                                                                 // and handle at end of ISR
 103   3                              break;
 104   3      
 105   3                } // end switch
 106   2              }
 107   1              else
 108   1              {
 109   2                // SMB0CN0_ARBLOST = 1, error occurred... abort transmission
 110   2                FAIL = 1;
 111   2              } // end SMB0CN0_ARBLOST if
 112   1      
 113   1              if (FAIL)                           // If the transfer failed,
 114   1              {
C51 COMPILER V9.60.0.0   INTERRUPTS                                                        08/25/2024 21:07:34 PAGE 3   

 115   2                SMB0CF &= ~0x80;                 // Reset communication
 116   2                SMB0CF |= 0x80;
 117   2                SMB0CN0_STA = 0;
 118   2                SMB0CN0_STO = 0;
 119   2                SMB0CN0_ACK = 0;
 120   2      
 121   2                SMB_BUSY = 0;                    // Free SMBus
 122   2      
 123   2                FAIL = 0;
 124   2                LED0 = 0;
 125   2      
 126   2                NUM_ERRORS++;                    // Indicate an error occurred
 127   2              }
 128   1      
 129   1              SMB0CN0_SI = 0;                             // Clear interrupt flag
 130   1      }
 131          
 132          
 133          //-----------------------------------------------------------------------------
 134          // TIMER3_ISR
 135          //-----------------------------------------------------------------------------
 136          //
 137          // TIMER3 ISR Content goes here. Remember to clear flag bits:
 138          // TMR3CN0::TF3H (Timer # High Byte Overflow Flag)
 139          // TMR3CN0::TF3L (Timer # Low Byte Overflow Flag)
 140          //
 141          //-----------------------------------------------------------------------------
 142          SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
 143          {
 144   1              SMB0CF &= ~0x80;                    // Disable SMBus
 145   1              SMB0CF |= 0x80;                     // Re-enable SMBus
 146   1              TMR3CN0 &= ~0x80;                    // Clear Timer3 interrupt-pending
 147   1                                                                                 // flag
 148   1              SMB0CN0_STA = 0;
 149   1              SMB_BUSY = 0;                       // Free SMBus
 150   1      }
 151          
 152          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    205    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
